# Structs
Structs are simple tools for keeping structured data. They are similar to tuples, but there are several key differences. Unlike tuples, no operations other than member access and assignment are defined for structs. And second, the members of structs are named.

In structs, you may declare struct attributes and declare other types. Struct methods are forbidden.

```
struct MyStructure
	use B = bool

	var x: B
	var mut y: & B = x // implicit value
```
Structs can be constructed in one of the following ways:
```
var b = true
var x = MyStructure(true, b) // in order
var x = MyStructure(y = b, x = true) // arbitrary order

var y = x // assignment
```

Their members can be accesed like attributes:
```
var y = x.x
var z = x.y
```

# Classes
Classes represent structures with operations on the data.

## Access modifiers
There are three access levels: `private`, `protected`, and `public`.

`private` fields can only be accessed from this class.

`protected` fields can only be accessed from this class or its subclasses.

`public` fields can be accessed by anyone.

By default, class members are private.

```
class Foo
	var x_: bool // default private
protected
	var y_: bool
public
	var z: bool
```

## Attributes, Methods, and Properties
A class can have the following members: attributes, methods and properties.

```
class Foo
public
	fn bar() // method
		pass

	var x: bool // attribute

	property y: bool // write-only property, auto backing field
		set = default
		protected get = default
```

## Attributes
Attributes are variables in classes.

### Static attributes
Static attributes are shared across all objects of that type.

```
class Foo
public
	var static mut x: bool = true
```

## Methods
Methods are essentially functions with access to class variables.
There are three important things to know about methods:
- Mutability: Methods are immutable by default; they cannot modify class variables. To make a method able to change mutable class variables, it must be declared as `fn mut foo()`.
- Virtual: Methods are static by default. To make use of polymorphism, you must use the `virtual` keyword: `fn virtual foo()`. When overriding a method, you must use the `override` keyword instead.
- Implicit return value: Where functions implicitly return an empty tuple, methods implicitly return a reference to their object (unless they are static; mutability is decided by the mutability of the called object).

```
class Foo
protected
	var mut x_: bool
public
	fn virtual foo()
		pass
	fn mut bar()
		x_ = not x_ // in this case, x_ is the same as this.x_
```

### Static methods
Static methods do not have access to class variables. They are essentially functions in the class's namespace.

```
class Foo
public
	fn static foo()
		return true
```

### Constructors
TODO
The following implicit constructors are created unless explicitly deleted:

Constructors of parent classes and members may be called in the constructor body. The following restrictions apply:
- Any non-static methods may not be called before the constructors.
- The constructors must be called in the correct order; The parent constructor(s), then members in order of declaration.

### Destructors
TODO
Destructors are implicitly generated, but can be defined by hand.
Destructors are automatically virtual if the class has any virtual functions.

Destuctors of members are automatically called. They are always called from the last declared to the first.

## Properties
Properties look like attributes, but actually run methods.

Each property may have the following:
- `fn set` - a mut method called when a value is assigned to the property. Has the implicit argument `value`. Always returns an empty tuple.
- `fn get` - The getter method. Returns the type of the property or a reference to it.
- `fn mut get` - A mut version of the getter method. If it is missing, the const version is always used. May return a mutable reference.

Either of the methods may have a stricter access level than the property itself. E.g. a public property may have a protected getter and not have the mutable getter at all.

```
class Foo
public
	property x: Foo
	// implicit access level as property; in this case public
		set = default // default implementation
		fn get // implicitly returns Foo
			return x
			// within setter and getter methods, x refers to the backing field, not to the property
	protected
		fn mut get: mut & Foo
			return x
```

## Inheritance
A class can inherit from a single other class and can implement any number of traits.
Traits will be discussed in the following section.

## Friends
Within a class, you can define other classes with access to private fields.
Friend functions differ from static methods by being outside the class's namespace.

```
class Foo
private
	var static x_: bool
public
	friend class Bar
	public
		fn foo()
			return Foo::x_
```

This is a complete example with most of the concepts explained:
```
class Foo
protected
	var mut x_: bool
	fn mut virtual foo(bool y): bool
		var ret = x
		x = y_
		return y_
public
	property virtual z: bool
		set
			z = value
		mut get
			return foo(z)
		get
			return z

class Bar: public Foo
protected
	fn mut override foo(bool y): bool
		return not y_

class Gaz: public Foo
public
	property override z: bool
		mut get
			return z
		// get and set stay the same
```