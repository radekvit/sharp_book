# Literals
Sharp has the following literals:

## Integer literals
Integer literals can be either untyped, or typed.
An untyped integer literal is any sequence of numbers, such as `42`.
A typed integer literal is any sequence of numbers followed by one of the built-in integer types, for example `42u16`.

Additionally, integers can be in base 10 (`42`), base 2 (`0b1001`), base 8 (`042`), or base 16 (`0x54`). This does not collide with the postfix type specification.

Integer literals may contain `'` characters to separate groups of digits (`19'000'000`).

## Floating point literals
Floating point literals are, too, optionally typed.
An untyped float literal is `1.0`.
A typed literal may be a floating point or integer literal followed by one of the built-in floating point type names, e.g. `1.0f32`, or `42f64`.

Floating point literals can be in base 10 (`1e-9`), base 2 (`0b1.001`), or base 16 (`0x5e.fa8E1ef`, exponent is denoted by capital `E` only, digits by lowercase letters only). Base 16 literals cannot be typed, as `f` is a hexa digit.

## Character literals
Character literals signify a single `char`. They are enclosed in single quotes (`'`). For example: `'c'`, `'âš›'`.

### Escaped characters
There are some escape sequences which can signify different characters.

* `\'` single quote
* `\"` double quote
* `\?` question mark
* `\\` backslash
* `\a` audible bell
* `\b` backspace
* `\f` form feed
* `\n` line feed
* `\r` carriage return
* `\t` horizontal tab
* `\v` vertical tab
* `\u{xxxxxx}` or `\U{xxxxxx}` a utf-8 character with up to 6 digits within the parentheses. Syntatically, it must be a valid utf-8 character.

## String literals
String literals are enclosed in double quotes (`"`). They can span multiple lines,
and all tab characters following a newline are not included in the resulting string.
```
fn foo()
	var s = "long string
	with multiple lines"
```

## Custom literals
For any or all of the four literals, we can define a custom literal.
These literals can be of any user defined type. They are created by suffixing any of the literals with `_name`, where *name* is the name of the custom literal.

We will show how to define our custom literals in one of the following chapters.

# Expressions
Expressions are very similar to other programming languages: expressions are evaluated according to the priority and associativity of operators and returns a value. The order of operations is strictly kept, and most expressions (with notable exceptions, for example `x = x++`) are well defined.

Sharp has the following operators, sorted by priority:

| **Priority** | **Operator** | **Operator name** | **Associativity**|
|:------------ |:------------:|:----------------- | ----------------:|
| 1.           | `::`         | scope resolution  | left             |
|              | `::<>`       | generic parameter |                  |
| 2.           | `&a`         | unary `&`         | right            |
|              | `*a`         | unary `*`         |                  |
| 4.           | `a++`        | postfix `++`      | left             |
|              | `a--`        | postfix `--`      |                  |
|              | `a()`        | function call     |                  |
|              | `a[]`        | indexing          |                  |
|              | `.`          | member select     |                  |
| 5.           | `++a`        | prefix `++`       | right            |
|              | `--a`        | prefix `--`       |                  |
|              | `+a`         | unary `+`         |                  |
|              | `-a`         | unary `-`         |                  |
|              | `not a`      | logical negation  |                  |
|              | `~a`         | bitwise negation  |                  |
|              | `new a`      | Ptr<T> creation   |                  |
| 6.           | `a ** b`     | power operator    |                  |
| 7.           | `a * b`      | multiplication    | left             |
|              | `a / b`      | division          |                  |
|              | `a % b`      | remainder         |                  |
| 8.           | `a + b`      | addition          |                  |
|              | `a - b`      | subtraction       |                  |
| 9.           | `<<`         | left shift        |                  |
|              | `>>`         | right shift       |                  |
| 10.          | `a & b`      | bit and           |                  |
| 11.          | `a ^ b`      | bit xor           |                  |
| 12.          | `a \| b`     | bit or            |                  |
| 13.          | `a < b`      | less than         |                  |
|              | `a > b`      | more than         |                  |
|              | `a <= b`     | less or equal     |                  |
|              | `a >= b`     | more or equal     |                  |
| 14.          | `a == b`     | equal             |                  |
|              | `a != b`     | not equal         |                  |
| 15.          | `a and b`    | logical and       |                  |
| 16.          | `a xor b`    | logical xor       |                  |
| 17.          | `a or b`     | logical or        |                  |
| 18.          | `new`        | new operator      | right            |
| 19.          | `a = b`      | assignment        |                  |
|              | `a += b`     | add and assign    |                  |
|              | `a -= b`     |subtract and assign|                  |
|              | `a *= b`     |multiply and assign|                  |
|              | `a /= b`     | divide and assign |                  |
|              | `a %= b`     |remainder and assign|                 |
|              | `a <<= b`    |shift left and assign|                |
|              | `a >>= b`    |shift right and assign|               |
|              | `a &= b`     |bitwise and and assign|               |
|              | `a ^= b`     |bitwise xor and assign|               |
|              | `a \|= b`    |bitwise or and assign|                |
|              | `a **= b`    | power and assign  |                  | 
